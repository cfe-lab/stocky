
# define messages that the webclient and the server have in common
# This module is imported by both python3 on the server and transcrypt on the
# webclient, so must be written accordingly


import typing


# NOTE: naming convention adopted here:
# MSG_WC_*: messages generated by the webclient
# MSG_RF_*: messages generated by the RFID reader
# MSG_SV_*: messages generated by the server

class CommonMSG:
    # the server has produced a random number
    MSG_SV_RAND_NUM = 'RND'
    # the USB device has changed state (presence/absence)
    MSG_SV_USB_STATE_CHANGE = 'USB_STATE'

    # the server is sending a list of all stock locations
    # in response to a MSG_WC_STOCK_CHECK
    MSG_SV_STOCK_LOCATIONS = 'STOCK_LOCATIONS'

    # the server is sending a list of expected stock items for the currently, specific location
    # in response to a MSG_WC_SET_STOCK_LOCATION
    MSG_SV_STOCK_LOCITEMS = 'STOCK_LOCITEMS'

    # the web client is performing a stock check
    # -- server should send a list of all locations with MSG_SV_STOCK_LOCATIONS
    MSG_WC_STOCK_CHECK = 'STOCK_MODE'

    # the web client has set a stock checking location
    # -- the server should send a list of all expected stock items for this location
    MSG_WC_SET_STOCK_LOCATION = 'STOCK_SET_LOC'

    # the web client is searching for a specific item ('radar mode')
    MSG_WC_RADAR_MODE = 'RADAR_MODE'

    # the RFID reader has produced some stock taking data
    MSG_RF_STOCK_DATA = 'STOCK_DATA'

    # the RFID reader has produced some radar data
    MSG_RF_RADAR_DATA = 'RADAR_DATA'

    # the RFID reader has produced a command response
    MSG_RF_CMD_RESP = 'RF_CMD_RESP'

    # the RFID 
    def __init__(self, msg: str, data: typing.Any) -> None:
        self.msg = msg
        self.data = data

    def as_dict(self) -> dict:
        return dict(msg=self.msg, data=self.data)
