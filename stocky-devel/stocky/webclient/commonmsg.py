
# define messages that the webclient and the server have in common
# This module is imported by both python3 on the server and transcrypt on the
# webclient, so must be written accordingly


import typing


# NOTE: naming convention adopted here:
# MSG_WC_*: messages generated by the webclient
# MSG_RF_*: messages generated by the RFID reader
# MSG_SV_*: messages generated by the server

class CommonMSG:
    # the server has produced a random number
    MSG_SV_RAND_NUM = 'SV_RND'

    # the server has produced a timer event
    MSG_SV_TIMER_TICK = 'SV_TIMER'

    # the USB device has changed state (presence/absence)
    MSG_SV_USB_STATE_CHANGE = 'SV_USB_STATE'

    # the server is sending a list of all stock locations
    # in response to a MSG_WC_STOCK_CHECK
    MSG_SV_NEW_STOCK_LIST = 'SV_NEW_STOCK_LIST'

    # the server wants to send a generic command directly to the RFID reader
    MSG_SV_GENERIC_COMMAND = 'SV_GENERIC_CMD'

    # the web client is sending uname, password info so
    # that server can try to authenticate
    MSG_WC_LOGIN_TRY = 'WC_LOGIN_TRY'

    # the server is providing the result of a login attempt sent by MSG_WC_LOGIN_TRY
    MSG_SV_LOGIN_RES = 'SV_LOGIN_RES'

    # the web client is performing a stock check
    # -- server should send a list of all locations with MSG_SV_STOCK_LOCATIONS
    MSG_WC_STOCK_CHECK = 'WC_STOCK_MODE'

    # the web client is sending a QAI cookie
    MSG_WC_QAI_AUTH = 'WC_AUTH_INFO'

    # the web client has set a stock checking location
    MSG_WC_SET_STOCK_LOCATION = 'WC_STOCK_SET_LOC'

    # the web client is searching for a specific item ('radar mode')
    MSG_WC_RADAR_MODE = 'WC_RADAR_MODE'

    # the RFID reader has produced some stock taking data
    MSG_RF_STOCK_DATA = 'RF_STOCK_DATA'

    # the RFID reader has produced some radar data
    MSG_RF_RADAR_DATA = 'RF_RADAR_DATA'

    # the RFID reader has produced a command response
    MSG_RF_CMD_RESP = 'RF_CMD_RESP'

    @classmethod
    def _init_class(cls):
        # NOTE: because of transcrypt, we cannot use a set..
        # nor can we seem to be able to define these are class variables.
        # instead, use a class method which is called upon import below
        cls.valid_msg_lst = [cls.MSG_SV_RAND_NUM, cls.MSG_SV_TIMER_TICK,
                             cls.MSG_SV_USB_STATE_CHANGE,
                             cls.MSG_SV_NEW_STOCK_LIST, cls.MSG_SV_GENERIC_COMMAND,
                             cls.MSG_SV_LOGIN_RES, cls.MSG_WC_STOCK_CHECK, cls.MSG_WC_QAI_AUTH,
                             cls.MSG_WC_SET_STOCK_LOCATION, cls.MSG_WC_LOGIN_TRY,
                             cls.MSG_WC_RADAR_MODE, cls.MSG_RF_STOCK_DATA, cls.MSG_RF_RADAR_DATA,
                             cls.MSG_RF_CMD_RESP]

        cls.valid_msg_dct = dict([(k, 1) for k in cls.valid_msg_lst])

    def __init__(self, msg: str, data: typing.Any) -> None:
        if not isinstance(msg, str):
            raise TypeError('msg must be a string!')
        if CommonMSG.valid_msg_dct.get(msg, None) is None:
            raise ValueError("illegal msg string '{}'".format(msg))
        self.msg = msg
        self.data = data

    def as_dict(self) -> dict:
        """return this class as a dict.
        NOTE: under transcrypt, there might be a spurious entry '__kwargtrans__'. If so, delete it
        """
        d = dict(msg=self.msg, data=self.data)
        # if '__kwargtrans__' in d:
        #    del d['__kwargtrans__']
        return d

    def __str__(self) -> str:
        return "CommonMSG({}, {})".format(self.msg, self.data)

    def is_from_server(self) -> bool:
        return self.msg.startswith('SV_')

    def is_from_webclient(self) -> bool:
        return self.msg.startswith('WC_')

    def is_from_rfid_reader(self) -> bool:
        return self.msg.startswith('RF_')


CommonMSG._init_class()
