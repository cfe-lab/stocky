
# define messages that the webclient and the server have in common
# This module is imported by both python3 on the server and transcrypt on the
# webclient, so must be written accordingly


import typing


# NOTE: naming convention adopted here:
# MSG_WC_*: messages generated by the webclient
# MSG_RF_*: messages generated by the RFID reader
# MSG_SV_*: messages generated by the server

class CommonMSG:
    # the server has produced a random number
    MSG_SV_RAND_NUM = 'SV_RND'

    # the server has produced a timer event
    MSG_SV_TIMER_TICK = 'SV_TIMER'

    # the USB device has changed state (presence/absence)
    MSG_SV_USB_STATE_CHANGE = 'SV_USB_STATE'

    # the server is sending a list of all stock locations
    # in response to a MSG_WC_STOCK_CHECK
    MSG_SV_NEW_STOCK_LIST = 'SV_NEW_STOCK_LIST'

    # the server wants to send a generic command directly to the RFID reader
    MSG_SV_GENERIC_COMMAND = 'SV_GENERIC_CMD'

    # the web client is performing a stock check
    # -- server should send a list of all locations with MSG_SV_STOCK_LOCATIONS
    MSG_WC_STOCK_CHECK = 'WC_STOCK_MODE'

    # the web client has set a stock checking location
    MSG_WC_SET_STOCK_LOCATION = 'WC_STOCK_SET_LOC'

    # the web client is searching for a specific item ('radar mode')
    MSG_WC_RADAR_MODE = 'WC_RADAR_MODE'

    # the RFID reader has produced some stock taking data
    MSG_RF_STOCK_DATA = 'RF_STOCK_DATA'

    # the RFID reader has produced some radar data
    MSG_RF_RADAR_DATA = 'RF_RADAR_DATA'

    # the RFID reader has produced a command response
    MSG_RF_CMD_RESP = 'RF_CMD_RESP'

    # NOTE: because of transcrypt, we cannot use a set..
    valid_msg_lst = [MSG_SV_RAND_NUM, MSG_SV_TIMER_TICK, MSG_SV_USB_STATE_CHANGE,
                     MSG_SV_NEW_STOCK_LIST, MSG_SV_GENERIC_COMMAND,
                     MSG_WC_STOCK_CHECK, MSG_WC_SET_STOCK_LOCATION, MSG_WC_RADAR_MODE,
                     MSG_RF_STOCK_DATA, MSG_RF_RADAR_DATA, MSG_RF_CMD_RESP]

    valid_msg_dct = dict([(k, 1) for k in valid_msg_lst])

    def __init__(self, msg: str, data: typing.Any) -> None:
        assert isinstance(msg, str), 'msg must be a string!'
        assert CommonMSG.valid_msg_dct.get(msg, None) is not None, "illegal msg string '{}'".format(msg)
        self.msg = msg
        self.data = data

    def as_dict(self) -> dict:
        return dict(msg=self.msg, data=self.data)

    def __str__(self) -> str:
        return "CommonMSG({}, {})".format(self.msg, self.data)

    def is_from_server(self) -> bool:
        return self.msg.startswith('SV_')

    def is_from_webclient(self) -> bool:
        return self.msg.startswith('WC_')

    def is_from_rfid_reader(self) -> bool:
        return self.msg.startswith('RF_')
